import { IfTS } from "~/components/configurable/IfConfig";
import { CodeTabs } from "~/components/Tabs";
import { Fn, Footnotes, FootnoteProvider } from "~/components/Footnotes";
import VitestCounterJS from "./snippets/jest-counter-js.mdx";
import VitestCounterTS from "./snippets/jest-counter-ts.mdx";
import VitestCounterTestJS from "./snippets/jest-counter-test-js.mdx";
import VitestCounterTestTS from "./snippets/jest-counter-test-ts.mdx";
import VitestLoremJS from "./snippets/jest-lorem-js.mdx";
import VitestLoremTS from "./snippets/jest-lorem-ts.mdx";
import VitestLoremTestJS from "./snippets/jest-lorem-test-js.mdx";
import VitestLoremTestTS from "./snippets/jest-lorem-test-ts.mdx";
import VitestClickOutsideJS from "./snippets/jest-clickoutside-js.mdx";
import VitestClickOutsideTS from "./snippets/jest-clickoutside-ts.mdx";
import VitestClickOutsideTestJS from "./snippets/vitest-clickoutside-test-js.mdx";
import VitestClickOutsideTestTS from "./snippets/vitest-clickoutside-test-ts.mdx";

<FootnoteProvider>
<Title>Vitest</Title>

## What is Vitest?

Vitest is a really fast unit test framework built on top of <Fn id="vite" term="Vite"><>[Vite](vitejs.dev/) is a versatile, integrated development environment with both development server and build pipeline, supporting many formats like TypeScript and postCSS out of the box.</></Fn>. It's quick to get started with, and it's easy to write tests for your components. Vitest isn't made primarily for testing frontend components but with the addition of some awesome packages we can make use of it in order to test our Solid.js components.

#### Packages

Required:

* [Vitest](https://vitest.dev/): user test suite based on vite
* [Solid.js Testing Library](https://github.com/solidjs/solid-testing-library): Solid.js-related testing helpers
* [JSDOM](github.com/jsdom/jsdom): virtual DOM environment to test client code on node.js

Optional, recommended:

* [JestDOM](https://testing-library.com/docs/ecosystem-jest-dom/): helpful assertions to test components
* [UserEvent](https://testing-library.com/docs/user-event/intro/): create events from a user perspective

## Getting Started

First let's get started with the installations of the required packages:

```bash
npm i -D vitest jsdom @solidjs/testing-library
# or
yarn add -D vitest jsdom @solidjs/testing-library
# or
pnpm add -D vitest jsdom @solidjs/testing-library
```

If you choose to install them, you can also add the recommended packages:

```bash
npm i -D @testing-library/jest-dom @testing-library/user-event
# or
yarn add -D @testing-library/jest-dom @testing-library/user-event
# or
pnpm add -D @testing-library/jest-dom @testing-library/user-event
```

#### Configuring Vitest

Now that we've installed the necessary packages, we'll need to configure vitest to work with Solid.js. Let's create a `vitest.config.ts` file in the root of our project. 

```ts
/// <reference types="vitest" />
/// <reference types="vite/client" />
// üëÜ do not forget to add the references above 

import { defineConfig } from "vite";
// use "solid-start/vite" if you are using solid-start:
import solidPlugin from "vite-plugin-solid";

export default defineConfig({
  plugins: [solidPlugin()],
  server: {
    port: 3000,
  },
  build: {
    target: "esnext",
  },
  test:{
    environment: "jsdom",
    // ‚ö†Ô∏è only use this if you want describe, it/test, expect, vi, etc.
    //    to be globally available without being imported from "vitest":
    globals: true,
    // ‚ö†Ô∏è setup for @testing-library/jest-dom if installed:
    setupFiles: ["node_modules/@testing-library/jest-dom/extend-expect"],
    transformMode: { web: [/\.[jt]sx?$/] },
  }
});
```

**Note:** Do not forget to add the `reference` types at the top of the file. If you do not add them, you will get a type error when you try to run your tests. Also, if you are using <Fn id="vite-plugins" term="plugins">Vite supports a lot of [plugins](https://vitejs.dev/plugins/) to handle certain file types.</Fn> like `vite-plugin-solid-svg`, you might need to copy their settings over from your vite-config.

Once we've created the config file, we'll need to add a script to our `package.json` file. 

```diff
{
  "name": "solid-app-name",
  "version": "0.0.0",
  "description": "",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "vite build",
    "serve": "vite preview",
+   "test": "vitest"
  },
  "license": "MIT",
  "devDependencies": {
    "@solidjs/testing-library": "^0.5.1",
    "@testing-library/jest-dom": "^5.16.5",
    "jsdom": "^20.0.3",
    "typescript": "^4.9.4",
    "vite": "^4.0.3",
    "vite-plugin-solid": "^2.5.0",
    "vitest": "^0.26.2"
  },
  "dependencies": {
    "solid-js": "^1.6.6"
  }
}

```

Now that we've added the script, we can run our tests by running `npm run test` or `yarn test`. However, there are no tests to run so we'll need to create some.

## Creating Tests

<IfTS fallback={
<>In JavaScript test files can be created with the <code>.test.js</code> or <code>.spec.js</code> extension. Some projects keep their tests in a seperate folder in the root of the project. Most developers like to name this folder <code>tests</code> or <code>__tests__</code>. However in some cases you may want to keep your tests in the same folder as the component you're testing. Explore the different styles and find what works best for you üôÇ.</>
}>In Typescript test files can be created with the `.test.ts` or `.spec.ts` extension. Some projects keep their tests in a seperate folder in the root of the project. Most developers like to name this folder `tests` or `__tests__`. However in some cases you may want to keep your tests in the same folder as the component you're testing. Explore the different styles and find what works best for you üôÇ.</IfTS>

Hint: If you want to move files in your project, use `git mv` in order to keep their references in the repository.

#### Testing an Application

In order to test an application, we will use the starter package and add a test for our `App`.

```ts
import { render } from '@solidjs/testing-library';
import App from './App';
// üëÜ make sure this points to the right path, it is
//    '../src/App' if you created a tests directory
import { describe, expect, it } from 'vitest';
// üëÜ only needed if you removed globals in vitest.config

describe('App', () => {
  it('should render the app', () => {
    const { getByText } = render(() => <App/>);
    expect(getByText('Learn Solid')).toBeInTheDocument();
    // üëÜ if you did not install jest-dom, you need to use
    //    expect(getByText('Learn Solid').ownerDocument).toBe(document);
    //    instead
  });
});
```

The above test will test to see if the phrase `Learn Solid` is in the `App` component once it is rendered. If it is, the test will pass. Otherwise, the test will fail. The snippet above is an example of a component test.

### Testing components

Let us test our most basic example: the counter. Consider the following component that you may have seen in the playground:

<CodeTabs
  js={[{ name: "counter.jsx", component: VitestCounterJS }]}
  ts={[{ name: "counter.tsx", component: VitestCounterTS }]}
/>

We want to test if there is a button that counts up on click; to make sure that it is working more than one time, we will try it a second time, so this is what our test looks like:

<CodeTabs
  js={[{ name: "counter.test.jsx", component: VitestCounterTestJS }]}
  ts={[{ name: "counter.test.tsx", component: VitestCounterTestTS }]}
/>

To use `toHaveTextContent`, we need to have `@testing-library/jest-dom` installed; otherwise, we need to replace that with

```ts
expect(button).toHaveProperty("textContent", "1");
```

which is a bit less legible and if it fails, the error message will be slightly less helpful.

If we want not to use `userEvent`, we can also use `fireEvent` from `@solidjs/testing-library`, which is synchronous, but be aware that these events are less like actual user events and may in some cases yield different results depending on the context.

### Testing re-usable logic

Re-usable logic, also known as <Fn id="primitives" term="hooks or primitives">In many frameworks, hooks/primitives are named `use[Something]`. Solid.js uses `create` as a prefix for its reactive primitives to denote that these are only called once inside the component.</Fn>, can also be tested using `@solidjs/testing-library`, by using the `renderHook` function.

Let us consider a hook that gives us a "Lorem ipsum" text with a certain number of words. We want to test it with 3, 2 and 5 words to make sure it works (select lorem.test.<IfTS fallback="js">ts</IfTS>):

<CodeTabs
  js={[
    { name: "lorem.js", component: VitestLoremJS },
    { name: "lorem.test.js", component: VitestLoremTestJS }
  ]}
  ts={[
    { name: "lorem.ts", component: VitestLoremTS },
    { name: "lorem.test.ts", component: VitestLoremTestTS }
  ]}
/>

### Testing custom directives

Solid.js has the useful ability to not only make logic, but also DOM interactions re-usable, through so-called custom directives. Obviously, we want the same convenience testing those as we have with hooks, so our testing library comes with a `renderDirective` utility.

The primitive we want to test is `onClickOutside`, which calls a function given in its argument, and we need to test it by clicking both inside and outside and check whether our function had been called:

<CodeTabs
  js={[
    { name: "click-outside.js", component: VitestClickOutsideJS },
    { name: "click-outside.test.js", component: VitestClickOutsideTestJS }
  ]}
  ts={[
    { name: "click-outside.ts", component: VitestClickOutsideTS },
    { name: "click-outside.test.ts", component: VitestClickOutsideTestTS }
  ]}
/>

<Footnotes />
</FootnoteProvider>
